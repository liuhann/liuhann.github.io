<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0">
    <title>postaljs - 前端组件化框架的救星 - Hand's blog
    </title>
    <link rel="alternate" href="http://localhost:8080/feed.xml" type="application/rss+xml" title="MY CONTENTS FOR LOOK BACK">
    <!--link(rel='stylesheet', href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic|Anonymous+Pro:400,700,400italic,700italic|Merriweather:400,700,300')-->
    <link rel="stylesheet" href="/css/main.css">
  </head>
  <body class="article-detail">
    <header class="header">
      <div class="content-wrap">
        <h1>postaljs - 前端组件化框架的救星</h1>
        <p class="author">Written by <span class="author">Hand</span>
        </p>
      </div>
    </header>
    <div id="content">
      <div class="content-wrap clearfix">
        <article class="article details">
          <section class="content"><p>Postaljs是一款js pub/sub 库，相当于为页面应用提供了一个新的事件/消息系统。&nbsp;作为原始<span class="caps">JS</span>开发，貌似对这种事件系统需求不大，然而要使用组件化开发，无论是reactjs还是angular，这种事件系统都会起到很大的作用。   </p>
<p><img src="/articles/20160223-postal-js/preview.png" alt="preview"></p>
<h2 id="why-postaljs">Why&nbsp;PostalJS</h2>
<p>其实，我开发js这么多年，一直也没有感觉有一个事件系统或者消息系统的需要。 主要原因还是在整个<span class="caps">DOM</span>页面中，要调用谁或者发送消息，直接 $ 一下就好了，当然也和应用性质相关。 
最近使用Reactjs开发，&nbsp;页面组件化倒是实现了，但有个关键问题就是组件间通讯。</p>
<p>我们知道reactjs组件是以一个树状形式组织的，作为<span class="caps">UI</span>组件化，相信这样的结构是有道理的，我们的DOM本身也是一个树状结构。&nbsp;然而组件之间的调用只能有2个方式：</p>
<ol>
<li>父调用子，使用refs</li>
<li>子调用父，使用props</li>
</ol>
<p>很多时候，如果2个组件间不是这样的关系，就只能一个组件逐层往上调用，直到一个共同的祖先，在顺次调用下去。这样是非常不合理的，我想跨越层次结构调用的需求是必然存在的。</p>
<p>特别的，在层次关系结构中，子调用父本身就是个很别扭的事情，就react而言，其实是应该是增加一个callback属性，专门用于子级元素的回调。</p>
<p>另外，我们也可以才用一个方法是将所有组件扁平化，虽然解决了逐层调用的尴尬问题，但也造成组件和ui原始特性的不匹配，有可能造成更大的不合理。 </p>
<p>在react官方，也给出的解决方案就是建议使用一个消息系统。 <a href="https://github.com/postaljs/postal.js">PostalJS</a>&nbsp;就是一个很好的选择。</p>
<p>Postal是一个典型的事件订阅框架。 这也是我们学计算机一个经典模型，它在<span class="caps">DOM</span>模型中事件的逐层传递特性(event&nbsp;bubble)之外，增加了一个事件模型。</p>
<p>这个事件模型其实是我们计算机的一个经典模型就是生产者/消费者模式：&nbsp;在postal中：  </p>
<ol>
<li>定义多个通道(channel)，生产者将消息(topic)发步(publish)到通道中，消息还可以携带数据。</li>
<li>消费者订阅(subscribe)一个通道的某种消息，进而进行后续处理</li>
<li>publish方和subscribe方是多对多的关系。</li>
</ol>
<h2 id="-">安装</h2>
<h3 id="-">普通安装</h3>
<p>引入 postal.lodash.min.js&nbsp;即可 </p>
<h3 id="npm-">npm安装</h3>
<blockquote>
<p>npm install postal&nbsp;–save-dev</p>
</blockquote>
<p>在js中</p>
<p>   var postal =&nbsp;require(“postal”);</p>
<p>然后就可以正常 订阅/发布&nbsp;消息了</p>
<h4 id="-">发布消息</h4>
<pre><code>  postal.publish({
      channel: &quot;orders&quot;,
      topic: &quot;item.add&quot;,
      data: {
          sku: &quot;AZDTF4346&quot;,
          qty: 21
      }
  });
</code></pre><h4 id="-">订阅消息</h4>
<pre><code>var subscription = postal.subscribe({
       channel: &quot;orders&quot;,
       topic: &quot;item.add&quot;,
       callback: function(data, envelope) {
           // `data` is the data published by the publisher.
           // `envelope` is a wrapper around the data <span class="amp">&amp;</span> contains
           // metadata about the message like the channel, topic,
           // timestamp and any other data which might have been
           // added by the sender.
       }
});
</code></pre><h2 id="-">结论</h2>
<p>不光用于react，在我们js开发中，有类似需求的场景都可以采用postal来进行处理。 </p>
</section>
        </article>
      </div>
    </div>
    <footer>
      <div class="content-wrap clearfix">
        <div class="nav"><a href="/">« Full blog</a></div>
        <section class="about"><p>This is hand’s blog. There are a lot of  work and collection. </p>

        </section>
        <section class="copy">
          <p>&copy; 2016 LiuHan &mdash; powered by&nbsp;<a href="https://github.com/jnordberg/wintersmith">Wintersmith</a>
          </p>
        </section>
      </div>
    </footer>
  </body>
</html>